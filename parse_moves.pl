#!/usr/bin/perl
use strict;
use warnings;
use Data::Dumper;

# Set of 2^18 ROM values. Each one is 8 bits. Low 4 bits are the
# new X move (0= no more, 1= move 1 etc.). Bit 4 is "draw" flag.
# Bit 5 is "computer wins" flag.
my @ROM= (0) x 262144;
my $tieflag= 0x10;
my $winflag= 0x20;

# Open the "moves" file which is generated by:
# ./gen_moves.pl | sort | uniq > moves
# and which looks like this:
#
# _________ O move 1 X move 5 O___X____
# _________ O move 2 X move 1 XO_______
# _________ O move 3 X move 5 __O_X____
# _________ O move 4 X move 1 X__O_____
# _________ O move 5 X move 1 X___O____
# _________ O move 6 X move 3 __X__O___
# _________ O move 7 X move 5 ____X_O__
# _________ O move 8 X move 2 _X_____O_
# _________ O move 9 X move 5 ____X___O
# O__OX_X__ O move 2 X move 3 wins
# O__OX_X__ O move 3 X move 2 OXOOX_X__
# OOX_X____ O move 4 X move 7 wins
# O__OX_X__ O move 6 X move 2 wins
# OOX_X____ O move 6 X move 7 wins
# OOX_X____ O move 7 X move 4 OOXXX_O__
# O__OX_X__ O move 8 X move 3 wins
# OOX_X____ O move 8 X move 4 wins
# O__OX_X__ O move 9 X move 2 wins
# OOX_X____ O move 9 X move 4 wins
# OOXXOO_XX O move 7 tie

# Given the board state as a 9-char string, return an 18-bit
# value with the top 9 bits representing the X move and the
# bottom 9 bits representing the O move.
sub parse_board {
  my $state= shift;
  my $xbitmap=0;
  my $obitmap=0;

  # Reverse the letters in the string so we get move 9 first
  foreach my $letter (reverse(split(m{}, $state))) {
    $xbitmap= $xbitmap << 1;
    $obitmap= $obitmap << 1;
    $xbitmap |= 1 if ($letter eq "X");
    $obitmap |= 1 if ($letter eq "O");
  }
  #printf("%s x bitmap %x, o bitmap %x\n", $state, $xbitmap, $obitmap);
  return(($xbitmap << 9) | $obitmap);
}

# Convert a decimal move into a bitmap value
sub move2bitmap {
  my $move= shift;
  return(1<< ($move-1));
}

open( my $IN, "<", "moves" ) || die("Can't open moves: $!\n");
while (<$IN>) {
    chomp;

    # Parse a tie
    if (m{^(.*) O move (\d) tie}) {
	my ($state, $omove)= ($1,$2);
	# Convert board into a bitmap, add on the new O move
	my $origstate= $state;
	$state= parse_board($state);
	$state |= move2bitmap($omove);
	$ROM[$state]= $tieflag;
        printf("%s %d: %05x => %02x\n", $origstate, $omove, $state, $tieflag);
        next;
    }

    # Parse a win
    if (m{^(.*) O move (\d) X move (\d) wins}) {
	my ($state, $omove, $xmove)= ($1,$2,$3);
	# Convert board into a bitmap, add on the new O move
	my $origstate= $state;
	$state= parse_board($state);
	$state |= move2bitmap($omove);
	$ROM[$state]= $xmove + $winflag;
        printf("%s %d: %05x => %02x\n", $origstate, $omove, $state, $xmove + $winflag);

	# Also insert the X move so that we indicate a win for the next
	# board state
	$state |= move2bitmap($xmove)<<9;
	$ROM[$state]= $winflag;
        printf("%s %d: %05x => %02x\n", $origstate, $omove, $state, $xmove + $winflag);
        next;
    }

    # Ordinary move
    if (m{^(.*) O move (\d) X move (\d) (.*)}) {
	my ($state, $omove, $xmove)= ($1,$2,$3);
	# Convert board into a bitmap, add on the new O move
	my $origstate= $state;
	$state= parse_board($state);
	$state |= move2bitmap($omove);
	$ROM[$state]= $xmove;
        printf("%s %d: %05x => %02x\n", $origstate, $omove, $state, $xmove);
        next;
    }
}
close($IN);

# Write out the ROM
open( my $OUT, ">", "ttt.rom" ) || die("Can't write to ttt.rom: $!\n");
print( $OUT "v2.0 raw\n" );
for my $i ( 0 .. ( 2**18 - 1 ) ) {
    printf( $OUT "%x ", $ROM[$i] ? $ROM[$i] : 0 );
    print( $OUT "\n" ) if ( ( $i % 8 ) == 7 );
}
close($OUT);
